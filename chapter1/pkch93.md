# 1장. 계층형 아키텍처의 문제는 무엇일까?

- [1장. 계층형 아키텍처의 문제는 무엇일까?](#1장-계층형-아키텍처의-문제는-무엇일까)
  - [계층형 아키텍처의 문제점](#계층형-아키텍처의-문제점)
    - [Database 기반의 설계를 유도한다.](#database-기반의-설계를-유도한다)
      - [Database 주도 설계?](#database-주도-설계)
    - [레이어의 경계를 무시할 수 있다.](#레이어의-경계를-무시할-수-있다)
    - [테스트를 어렵게 만든다.](#테스트를-어렵게-만든다)
    - [Use Case를 숨길 수 있다.](#use-case를-숨길-수-있다)
    - [병렬로 작업하는 것을 어렵게 만듬](#병렬로-작업하는-것을-어렵게-만듬)
  - [마무리](#마무리)

Layered architecture의 레이어 `Layers`는 서로 다른 레이어에 영향을 주지 않고 독립적으로 관리할 수 있다.

![](https://user-images.githubusercontent.com/30178507/153755148-88ba67fc-880d-49db-9117-66cfb8f32ef3.png)

즉, 요청을 받아 적절한 비즈니스 로직으로 라우팅하는 **Web** 레이어와 도메인 엔티티의 현재 상태를 수정, 조회하기 위한 **Persistence** 레이어에 상관없이 **Domain** 레이어에서 비즈니스 로직을 작성할 수 있다. **Web**과 **Persistence** 레이어는 **Domain** 레이어의 로직에는 영향을 미치지 않기 때문에 구현 기술을 자유롭게 바꿀 수 있다.

이렇게 레이어를 잘 활용하면 현재 구현된 기능에 영향을 주는 것 없이 새로운 기능을 구현할 수 있다. 따라서 좋은 Layerd Architecture는 options을 열어두고 외부 요인과 변화하는 요구사항에 빠르게 대처할 수 있도록 도와준다.

단, 잘못하면 레이어는 잘못된 습관이 스며들 수 있도록 하는 많은 측면들이 존재하며 시간이 지날수록 애플리케이션의 변화를 어렵게 만든다.

## 계층형 아키텍처의 문제점

### Database 기반의 설계를 유도한다.

전통적인 Layered Architecture는 데이터베이스에 기초한다. 이는 몇몇 이유에서 문제가 있다.

먼저 비즈니스 로직을 작성하는데는 오로지 비즈니즈 로직의 요구사항을 이해하고 정확하게 구현하는 것에 초점을 맞춰야한다. 그래야 이를 바탕으로 Persistence와 Web 레이어를 구축할 수 있다.

이 과정에서 데이터베이스 중심적인 설계를 불러오는 요소는 ORM 프레임워크를 사용하는 것이다. ORM 프레임워크를 Layered Architecture에 함께 사용하는 것은 Persistence 측면에서 비즈니스 로직을 녹일 우려가 있다.

![](https://user-images.githubusercontent.com/30178507/153755150-24e184b7-1f62-41da-b947-af69b0a2a741.png)

즉, Domain 레이어의 Entity는 Persistence 레이어와 강한 결합을 이끌게 된다. 이는 도메인 로직을 구현하면서 eager, lazy 로딩 문제, 트랜잭션 관리, 캐시 초기화 등의 문제들을 신경쓰게 만든다. 또한 Persistence 레이어의 코드가 사실상 Domain 레이어의 코드에 통합되어 있기 때문에 다른 코드가 없으면 어느 하나 변경을 하기 어렵게 만든다.

> 즉, Persistence 레이어에 속하는 ORM 프레임워크를 함부로 변경할 수 없다는 것을 의미하는 것으로 보인다.

#### Database 주도 설계?

저자가 말하는 Database 주도 설계란 무엇을 말하는걸까?

처음에는 비즈니스 로직을 쿼리에 녹여내는 설계를 말하는게 아닐까 싶었다. 비즈니스 로직이 쿼리에 녹아들도록 만들기 떄문에 쿼리를 먼저 생각해볼 수 밖에 없으므로 이런 이유가 Layered Architecture가 데이터베이스 주도의 설계를 유도하는게 아닐까 싶었다.

다만, 저자가 영속성 계층에 대한 이야기와 JPA를 예시로 들면서 영속성 관점과 비즈니스 규칙을 섞을때에 대한 이야기를 하는거 보면 비즈니스 로직이 쿼리에 녹아 드는 부분을 이야기하는 것은 아니라고 생각이 든다.

그러면 결국 영속성 계층을 먼저 생각하는 것을 Database 주도 설계라고 이야기 하는 걸로 보인다. 다만, 애플리케이션을 구성하는 요소 중에 데이터베이스와 쿼리 성능을 생각하지 않을 수 없을텐데 이에 대한 고민이 선행되지 않아도 괜찮을까라는 의문이 든다.

### 레이어의 경계를 무시할 수 있다.

Layered Architecture는 기본적으로 하위 바탕이 되는, 의존하고 있는 레이어에는 접근을 허용한다. 단, 이 부분이 Layered Architectured 스타일에서 이 룰을 강제하지 않는다. 때문에 레이어에 어울리지 않는 각종 컴포넌트, 유틸 클래스 등이 하위 레이어에 몰릴 수 있다.

![](https://user-images.githubusercontent.com/30178507/153755153-b8cdf128-d73d-45bc-9134-afa8b8f8a17e.png)

따라서 위와 같이 Persistence 레이어에 모든것이 몰려있는 기이한 현상이 나타날 수 있다.

> 위 캡처와 같이 Helper나 Utils 클래스는 특정 레이어에 상관없이 접근할 수 있는 것이 좋다. 

우리 아키텍처에서 위와 같은 현상을 막길 원한다면 아키텍처 룰을 통해 강제하거나 만약 강제하지 못한다면 레이어는 최선이 아닐 수 있다.

### 테스트를 어렵게 만든다.

![](https://user-images.githubusercontent.com/30178507/153755156-9493f5a5-e466-4d6c-bcba-74bb54f66bb6.png)

위와 캡처와 같이 중간 레이어를 무시하고 Web 레이어가 바로 Persistence 레이어에 접근하는 경우가 있을 수 있다. 처음 위와 같이 사용한다면 괜찮아 보일 수 있지만 계속해서 위와 같은 형태가 이어진다면 다음 2가지 문제가 있을 수 있다.

먼저, 기능 확장에 문제가 생길 수 있다. Web 레이어에서 단일 단위로 접근하여 만든 비즈니스 로직은 더 많은 도메인 로직이 추가될수록 애플리케이션 전반에 필수 도메인 로직이 분산되고 책임이 뒤섞여 복잡도를 높일 수 있다.

두번째는 Web 레이어의 테스트 문제이다. Domain 레이어 뿐만 아니라 Persistence 레이어에 목킹 처리가 필요하다. 이는 테스트 작성에 복잡도를 더할 수 있다. 복잡한 테스트는 결국 일정 등의 이유로 테스트가 작성되지 않는 로직으로 이어질 수 있다. 테스트 코드를 작성하는 것보다 의존성을 이해하고 목킹하는데 더 많은 시간이 걸리기 때문이다.

### Use Case를 숨길 수 있다.

우리는 보통 기능을 추가하거나 변경할 때 올바른 위치를 찾기 마련이다. 때문에 아키텍처는 이를 빠르게 찾을 수 있도록 도와줄 수 있어야한다. 단, Layered Architecture가 이를 얼마나 도와줄 수 있나?

앞서 본 것처럼 Layered Architecture는 도메인 로직이 여러 레이어에 걸쳐서 쉽게 흩어질 수 있다. 이는 새로운 기능을 추가하는데 올바른 위치를 찾는 것을 어렵게 만든다. 거기에 더해서 Layered Architecture는 도메인 서비스의 크기에 대해서 어떠한 룰로 강제를 하지 않는다. 이는 하나의 도메인 서비스가 여러 Use Case에 대한 도메인 로직을 가질 수 있다는 의미이고 그만큼 비대해진다는 의미이다.

![](https://user-images.githubusercontent.com/30178507/153755157-2b61ef69-d2a2-4cf4-b8ff-29141c747e6b.png)

위와 같이 비대해진 서비스는 너무 많은 의존성을 가지므로 테스트를 어렵게 만들 뿐만 아니라 Use Case를 담당하는 서비스를 찾기 어렵게 만든다.

### 병렬로 작업하는 것을 어렵게 만듬

만약 3명의 개발자가 있고 하나의 기능에서 각각 Web, Domain, Persistence 도메인을 맡아서 개발한다고 가정한다. 이 경우 3명의 개발자가 각각 기능을 구현하기 위해서 작업을 시작할 수 없다. Domain 레이어의 작업자는 Persistence 작업이 될 때까지 대기해야하며 Web 레이어 작업자 또한 Domain 레이어 작업을 대기해야한다.

3명의 개발자가 각 레이어 간 interface나 스팩을 정의해두고 로직을 병렬적으로 개발할수도 있다. 단, 이 경우는 데이터베이스 기반의 설계를 하지 않는 경우에만 가능하다.

## 마무리

Layered Architecture는 위와 같은 문제가 있다. 만약 엄격한 룰을 강제하여 사용하고 있다면 Layered Architecture는 더 유지보수하기 좋은 아키텍처가 될 수 있다.

단, 그만큼 Layered Architecture는 잘못된 것들을 허용한다는 것을 의미한다. 따라서 Layered Architecture의 문제점을 염두하면서 개발한다면 보다 유지보수하기 좋은 소프트웨어를 구축하는데 도움을 줄 수 있다.